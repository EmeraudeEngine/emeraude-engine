/*
 * Emeraude/Scenes/Scene.hpp
 * This file is part of Emeraude
 *
 * Copyright (C) 2012-2023 - "LondNoir" <londnoir@gmail.com>
 *
 * Emeraude is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Emeraude is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Emeraude; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301  USA
 *
 * Complete project and additional information can be found at :
 * https://bitbucket.org/londnoir/emeraude
 * 
 * --- THIS IS AUTOMATICALLY GENERATED, DO NOT CHANGE ---
 */

#pragma once

/* C/C++ standard libraries. */
#include <string>
#include <set>
#include <vector>
#include <memory>

/* Local inclusions for inheritances. */
#include "NamedItem.hpp"
#include "Time/TimedEventsInterface.hpp"
#include "Observer.hpp"
#include "Observable.hpp"

/* Local inclusions for usages. */
#include "MasterControl/Console.hpp"
#include "Physics/PhysicalEnvironmentProperties.hpp"
#include "Physics/Collider.hpp"
#include "Graphics/Renderable/AbstractBackground.hpp"
#include "Graphics/Renderable/AbstractSceneArea.hpp"
#include "Graphics/Renderable/AbstractSeaLevel.hpp"
#include "RenderBatch.hpp"
#include "StaticEntity.hpp"
#include "Node.hpp"
#include "OctreeSector.hpp"

/* Forward Declarations */
namespace Emeraude::Graphics
{
	class Renderer;
}

namespace Emeraude::Scenes
{
	/**
	 * @brief Class that describe a whole scene through a nodes structure.
	 * @extends Libraries::NamedItem A scene is a named object in the engine.
	 * @extends Libraries::Time::TimedEventsInterface A scene can have timed events.
	 * @extends Libraries::Observer The scene will observe the scene node tree and static entity list.
	 * @extends Libraries::Observable Scene will notifies its content change.
	 */
	class Scene final : public Libraries::NamedItem, public Libraries::Time::TimedEventsInterface, public Libraries::Observer, public Libraries::Observable
	{
		public:

			/** @brief Observable notification codes. */
			enum NotificationCode
			{
				NodeCreated,
				NodeDeleting,
				NodeDeleted,
				StaticCreated,
				StaticDeleting,
				StaticDeleted,
				/* Enumeration boundary. */
				MaxEnum
			};

			/** @brief Class identifier. */
			static constexpr auto ClassId{"Scene"};

			/** @brief Observable class unique identifier. */
			static const size_t ClassUID;
			
			static const std::string DefaultOctreeName;

			/**
			 * @brief Constructs a scene.
			 * @param name A reference to a string to name it.
			 * @param boundary The distance in all directions to limit the area.
			 * @param background A reference to a background smart pointer. Default autogenerated.
			 * @param sceneArea A reference to a sceneArea smart pointer. Default autogenerated.
			 * @param seaLevel A reference to a seaLevel smart pointer. Default none.
			 */
			explicit Scene (const std::string & name, float boundary, const std::shared_ptr< Graphics::Renderable::AbstractBackground > & background = nullptr, const std::shared_ptr< Graphics::Renderable::AbstractSceneArea > & sceneArea = nullptr, const std::shared_ptr< Graphics::Renderable::AbstractSeaLevel > & seaLevel = nullptr) noexcept;

			/** @brief Deleted copy constructor. */
			Scene (const Scene & copy) = delete;

			/** @brief Deleted move constructor. */
			Scene (Scene && copy) = delete;

			/** @brief Deleted assignment operator. */
			Scene & operator= (const Scene & other) = delete;

			/** @brief Deleted move assignment operator. */
			Scene & operator= (Scene && other) = delete;

			/** @brief Destroy the scene. */
			~Scene () override;

			/** @copydoc Libraries::Observable::is() */
			[[nodiscard]]
			bool is (size_t classUID) const noexcept override;

			/**
			 * @brief Sets the scene boundary.
			 * @return void
			 */
			void setBoundary (float boundary) noexcept;

			/**
			 * @brief Returns the boundary in one direction.
			 * @note To get the total size of an axis, you need to multiply it by two or use AbstractSceneArea::size().
			 * @return float
			 */
			[[nodiscard]]
			float boundary () const noexcept;

			/**
			 * @brief Returns the square size of the area.
			 * @return float
			 */
			[[nodiscard]]
			float size () const noexcept;

			/**
			 * @brief Initializes the scene and get it ready for playing.
			 * @param coreSettings A reference to core settings.
			 * @param renderer A reference to renderer.
			 * @return bool
			 */
			[[nodiscard]]
			bool initialize (Settings & coreSettings, Graphics::Renderer & renderer) noexcept;

			/**
			 * @brief Prepares the scene to be removed from playing.
			 * @return void
			 */
			void shutdown () noexcept;

			/**
			 * @brief Sets the scene physical environment properties.
			 * @param properties A reference to a physical environment properties.
			 * @return void
			 */
			void setPhysicalEnvironmentProperties (const Physics::PhysicalEnvironmentProperties & properties) noexcept;

			/**
			 * @brief Creates a static entity in the scene.
			 * @param name The name of the entity.
			 * @param coordinates A reference to a coordinates for the initial location of the entity. Default origin.
			 * @return std::shared_ptr< StaticEntity >
			 */
			[[nodiscard]]
			std::shared_ptr< StaticEntity > createStaticEntity (const std::string & name, const Libraries::Math::Coordinates< float > & coordinates = {}) noexcept;

			/**
			 * @brief Creates a static entity in the scene using only a position.
			 * @param name The name of the entity.
			 * @param position A reference to a vector.
			 * @return std::shared_ptr< StaticEntity >
			 */
			[[nodiscard]]
			inline
			std::shared_ptr< StaticEntity >
			createStaticEntity (const std::string & name, const Libraries::Math::Vector< 3, float > & position) noexcept
			{
				return this->createStaticEntity(name, Libraries::Math::Coordinates< float >{position});
			}

			/**
			 * @brief Removes a static entity from the scene.
			 * @param name A reference to a string for the entity name.
			 */
			bool removeStaticEntity (const std::string & name) noexcept;

			/**
			 * @brief Adds a global effect to the scene.
			 * @param effect A reference to an effect interface smart pointer.
			 */
			void addEnvironmentEffect (const std::shared_ptr< Saphir::EffectInterface > & effect) noexcept;

			/**
			 * @brief Returns whether a global effect is already present on the scene.
			 * @param effect A reference to an effect interface smart pointer.
			 * @return bool
			 */
			[[nodiscard]]
			bool isEnvironmentEffectPresent (const std::shared_ptr< Saphir::EffectInterface > & effect) const noexcept;

			/**
			 * @brief Clears every effect from the scene.
			 * @return void
			 */
			void clearEnvironmentEffects () noexcept;

			/**
			 * @brief Clears the whole scene.
			 * @return void
			 */
			void clear () noexcept;

			/**
			 * @brief Returns whether the default octree is enabled.
			 * @return bool
			 */
			[[nodiscard]]
			bool defaultOctreeEnabled () const noexcept;

			/**
			 * @brief Returns the default octree.
			 * @note Can be nullptr.
			 * @return std::shared_ptr< OctreeSector >
			 */
			[[nodiscard]]
			std::shared_ptr< OctreeSector > getDefaultOctree () noexcept;

			/**
			 * @brief Returns a named octree.
			 * @note Can be nullptr.
			 * @param octreeName A reference to a string.
			 * @return std::shared_ptr< OctreeSector >
			 */
			[[nodiscard]]
			std::shared_ptr< OctreeSector > getOctree (const std::string & octreeName) noexcept;

			/**
			 * @brief Builds an octree of the scene.
			 * @param octreeName The octree name.
			 * @return std::shared_ptr< OctreeSector >
			 */
			std::shared_ptr< OctreeSector > buildOctree (const std::string & octreeName) noexcept;

			/**
			 * @brief Destroys the main octree of the scene.
			 * @param octreeName The octree name.
			 * @return bool
			 */
			bool destroyOctree (const std::string & octreeName) noexcept;

			/**
			 * @brief Destroys all octree of the scene.
			 * @return void
			 */
			void destroyAllOctrees () noexcept;

			/**
			 * @brief Rebuild an octree layer.
			 * @param octreeName A reference to a string.
			 * @param keepElements Keep elements from the previous octree. Default true.
			 * @return bool
			 */
			bool rebuildOctree (const std::string & octreeName, bool keepElements = true) noexcept;

			/**
			 * @brief Rebuild all octree layers.
			 * @param keepElements Keep elements from the previous octrees. Default true.
			 * @return void
			 */
			void rebuildAllOctrees (bool keepElements = true) noexcept;

			/**
			 * @brief Removes all nodes.
			 * @return void
			 */
			void resetNodeTree () noexcept;

			/**
			 * @brief This method is called by the Core every logic cycle.
			 * @param cycle The cycle number of the engine.
			 */
			void processLogics (size_t cycle) noexcept;

			/**
			 * @brief Updates the render lists from a point of view.
			 * @param renderTarget A reference to the render target smart pointer.
			 * @param opaqueRenderList A reference to a render list for opaque renderable objects.
			 * @param translucentRenderList A reference to a render list for translucent renderable objects.
			 * @return bool
			 */
			bool getRenderLists (const std::shared_ptr< Graphics::RenderTarget::Abstract > & renderTarget, RenderBatch::List & opaqueRenderList, RenderBatch::List & translucentRenderList) const noexcept;

			/**
			 * @brief Update the video memory for a render target before the render.
			 * @param renderTarget A reference to the render target smart pointer.
			 * @return void
			 */
			void updateVideoMemoryForRendering (const std::shared_ptr< Graphics::RenderTarget::Abstract > & renderTarget) const noexcept;

			/**
			 * @brief Performs a shadow casting pass of the scene.
			 * @param renderTarget A reference to the render target smart pointer.
			 * @param commandBuffer A reference to a command buffer.
			 * @return void
			 */
			void castShadows (const std::shared_ptr< Graphics::RenderTarget::Abstract > & renderTarget, const Vulkan::CommandBuffer & commandBuffer) noexcept;

			/**
			 * @brief Renders the scene.
			 * @param renderTarget A reference to the render target smart pointer.
			 * @param commandBuffer A reference to a command buffer.
			 * @return void
			 */
			void render (const std::shared_ptr< Graphics::RenderTarget::Abstract > & renderTarget, const Vulkan::CommandBuffer & commandBuffer) const noexcept;

			/**
			 * @brief Returns the master control console.
			 * @return const MasterControl::Console &
			 */
			[[nodiscard]]
			const MasterControl::Console & masterControlConsole () const noexcept;

			/**
			 * @brief Returns the master control console.
			 * @return MasterControl::Console &
			 */
			[[nodiscard]]
			MasterControl::Console & masterControlConsole () noexcept;

			/**
			 * @brief Returns the light set of the scene.
			 * @return const LightSet &
			 */
			[[nodiscard]]
			const LightSet & lightSet () const noexcept;

			/**
			 * @brief Returns the light set of the scene.
			 * @return LightSet &
			 */
			[[nodiscard]]
			LightSet & lightSet () noexcept;

			/**
			 * @brief Returns the scene physical environment properties.
			 * @return const Physics::PhysicalEnvironmentProperties &
			 */
			[[nodiscard]]
			const Physics::PhysicalEnvironmentProperties & physicalEnvironmentProperties () const noexcept;

			/**
			 * @brief Returns the scene physical environment properties.
			 * @return Physics::PhysicalEnvironmentProperties &
			 */
			[[nodiscard]]
			Physics::PhysicalEnvironmentProperties & physicalEnvironmentProperties () noexcept;

			/**
			 * @brief Sets the scene background.
			 * @param background A reference to a background smart pointer.
			 */
			void setBackground (const std::shared_ptr< Graphics::Renderable::AbstractBackground > & background) noexcept;

			/**
			 * @brief Returns the current background of the scene.
			 * @return const std::shared_ptr< Graphics::Renderable::AbstractBackground > &
			 */
			[[nodiscard]]
			const std::shared_ptr< Graphics::Renderable::AbstractBackground > & background () const noexcept;

			/**
			 * @brief Sets the scene sceneArea.
			 * @param sceneArea A reference to a sceneArea smart pointer.
			 */
			void setSceneArea (const std::shared_ptr< Graphics::Renderable::AbstractSceneArea > & sceneArea) noexcept;

			/**
			 * @brief Returns the current scene area.
			 * @return const std::shared_ptr< Graphics::Renderable::AbstractSceneArea > &
			 */
			[[nodiscard]]
			const std::shared_ptr< Graphics::Renderable::AbstractSceneArea > & sceneArea () const noexcept;

			/**
			 * @brief Sets the scene sea level.
			 * @param seaLevel A reference to a background smart pointer.
			 */
			void setSeaLevel (const std::shared_ptr< Graphics::Renderable::AbstractSeaLevel > & seaLevel) noexcept;

			/**
			 * @brief Returns the current water level.
			 * @return const std::shared_ptr< Graphics::Renderable::AbstractSeaLevel > &
			 */
			[[nodiscard]]
			const std::shared_ptr< Graphics::Renderable::AbstractSeaLevel > & seaLevel () const noexcept;

			/**
			 * @brief Returns the root scene node from the scene.
			 * @return const std::shared_ptr< Node > &
			 */
			[[nodiscard]]
			const std::shared_ptr< Node > & root () const noexcept;

			/**
			 * @brief Searches from the top oh the node tree the first named node.
			 * @param nodeName A reference to a string.
			 * @return std::shared_ptr< Node >
			 */
			[[nodiscard]]
			std::shared_ptr< Node > findNode (const std::string & nodeName) const noexcept;

			/**
			 * @brief Returns the static entity list.
			 * @return const std::map< std::string , std::shared_ptr< StaticEntity > > &
			 */
			[[nodiscard]]
			const std::map< std::string , std::shared_ptr< StaticEntity > > & staticEntities () const noexcept;

			/**
			 * @brief Returns a list of modifiers present in the scene.
			 * @return const std::set< std::shared_ptr< AbstractModifier > > &
			 */
			[[nodiscard]]
			const std::set< std::shared_ptr< AbstractModifier > > & modifiers () const noexcept;

			/**
			 * @brief Returns the list of active global effects in the scene.
			 * @return const Saphir::EffectsList &
			 */
			[[nodiscard]]
			const Saphir::EffectsList & environmentEffects () const noexcept;

			/**
			 * @brief Checks if a position is inside the scene area.
			 * @param worldPosition An absolute position.
			 * @return bool
			 */
			[[nodiscard]]
			bool contains (const Libraries::Math::Vector< 3, float > & worldPosition) const noexcept;

			/**
			 * @brief Returns a random position within the scene area.
			 * @return Vector< 3, float >
			 */
			Libraries::Math::Vector< 3, float > getRandomPosition () const noexcept;

			/**
			 * @brief Returns node count and depth.
			 * @return std::array< size_t, 2 >
			 */
			[[nodiscard]]
			std::array< size_t, 2 > getNodeStatistics () const noexcept;

			/**
			 * @brief Returns sector count and depth.
			 * @param sector A reference to a top sector node smart pointer.
			 * @return array< size_t, 2 >
			 */
			[[nodiscard]]
			static std::array< size_t, 2 > getSectorStatistics (const std::shared_ptr< Scenes::OctreeSector > & sector) noexcept;

			/**
			 * @brief Turns on or off the sector border displaying.
			 * @note Only populated sector will be shown.
			 * @param state The state.
			 */
			void showSectors (bool state) noexcept;

			/**
			 * @brief Toggles the sector border displaying and return the current state.
			 * @return bool
			 */
			inline
			bool
			toggleSectorsDisplay () noexcept
			{
				this->showSectors(!m_flags[ShowSectors]);

				return m_flags[ShowSectors];
			}

			/**
			 * @brief Turns on or off the artificial horizon displaying.
			 * @param state The state.
			 * @param space Space between lines, only useful when enabling.
			 */
			void showGroundZero (bool state, float space = 100.0F) noexcept;

			/**
			 * @brief Toggles the artificial horizon displaying and return the current state.
			 * @return bool
			 */
			inline
			bool
			toggleGroundZeroDisplay () noexcept
			{
				this->showGroundZero(!m_flags[ShowGroundZero]);

				return m_flags[ShowGroundZero];
			}

			/**
			 * @brief Turns on or off the boundaries displaying.
			 * @param state The state.
			 * @param space Space between lines, only useful when enabling.
			 */
			void showBoundaries (bool state, float space = 1000.0F) noexcept; // NOLINT(*-magic-numbers)

			/**
			 * @brief Toggles the artificial boundaries and return the current state.
			 * @return bool
			 */
			inline
			bool
			toggleBoundariesDisplay () noexcept
			{
				this->showBoundaries(!m_flags[ShowBoundaries]);

				return m_flags[ShowBoundaries];
			}

			/**
			 * @brief Returns a string with some statistics about the scene.
			 * @note Debug purpose.
			 * @param printNodeSystem Print information about node system.
			 * @param printStaticEntitySystem Print information about static entity system.
			 * @param printSectorSystem Print information about sector system.
			 * @param printTrees Enable the scene node tree and the scene octree.
			 * @return std::string
			 */
			[[nodiscard]]
			std::string getStatisticsString (bool printNodeSystem, bool printStaticEntitySystem, bool printSectorSystem, bool printTrees = false) const noexcept;

			/**
			 * @brief Refreshes all renderable instances used in the scene.
			 * @param renderableInstance A pointer to a renderable instance.
			 * @return void
			 */
			void refreshRenderableInstances (const std::shared_ptr< Graphics::RenderTarget::Abstract > & renderTarget) const noexcept;

		private:

			/** @copydoc Libraries::Observer::onNotification() */
			[[nodiscard]]
			bool onNotification (const Libraries::Observable * observable, int notificationCode, const std::any & data) noexcept override;

			/**
			 * @brief Loops over each renderable instance of the scene
			 * @param function A reference to a function.
			 * @return void
			 */
			void forEachRenderableInstance (const std::function< bool (Graphics::RenderableInstance::Abstract & renderableInstance) > & function) const noexcept;

			/**
			 * @brief Checks a notification from the master console control.
			 * @param notificationCode The notification code from MasterControl::Console::NotificationCode enum.
			 * @param data A reference to the notification payload.
			 * @return bool
			 */
			bool checkMasterControlConsoleNotification (int notificationCode, const std::any & data) noexcept;

			/**
			 * @brief Checks a notification from a scene node.
			 * @param observableNode A pointer to the node.
			 * @param notificationCode The notification code from Node::NotificationCode enum.
			 * @param data A reference to the notification payload.
			 * @return bool
			 */
			bool checkNodeNotification (const Node * observableNode, int notificationCode, const std::any & data) noexcept;

			/**
			 * @brief Checks a notification from a scene entity.
			 * @param observableEntity A pointer to the entity.
			 * @param notificationCode The notification code from AbstractEntity::NotificationCode enum.
			 * @param data A reference to the notification payload.
			 * @return bool
			 */
			bool checkEntityNotification (const AbstractEntity * observableEntity, int notificationCode, const std::any & data) noexcept;

			/**
			 * @brief Initializes the base component (camera, microphone) of the scene.
			 * @note This is a sub-part of initialize() method.
			 * @return bool
			 */
			[[nodiscard]]
			bool initializeBaseComponents () noexcept;

			/**
			 * @brief Saves scene global visual components.
			 * @param renderer A reference to the renderer.
			 * @return void
			 */
			void registerSceneVisualComponents (Graphics::Renderer & renderer) noexcept;

			/**
			 * @brief Creates an octree root sector according to the scene boundaries.
			 * @return std::shared_ptr< OctreeSector >
			 */
			[[nodiscard]]
			std::shared_ptr< OctreeSector > createOctreeRootSector () const noexcept;

			/**
			 * @brief Rebuilds an octree.
			 * @param octreeIt A reference to the octree smart pointer.
			 * @param keepElements Keep elements from the previous octree.
			 * @return bool
			 */
			bool rebuildOctree (const std::map< std::string, std::shared_ptr< Scenes::OctreeSector > >::iterator & octreeIt, bool keepElements) noexcept;

			/**
			 * @brief Inserts node elements to an existing octree.
			 * @note The octree sector must be the root.
			 * @param octree A reference to the octree smart pointer.
			 * @return bool
			 */
			[[deprecated("Unused function")]]
			bool insertSceneElementsToOctree (const std::shared_ptr< Scenes::OctreeSector > & octree) noexcept;

			/**
			 * @brief Executes a collision test between scene at a sector.
			 * @note This is a recursive method with sub-sector.
			 * @param sector A reference to the current sector tested.
			 * @param stats A reference to a array of data to keep track of statistics on the scene collisions.
			 * @return void
			 */
			void sectorCollisionTest (const OctreeSector & sector, std::array< size_t, 3 > & stats) noexcept;

			/**
			 * @brief Checks if a scene node is clipping with the scene area boundaries.
			 * @param node A reference to a node smart pointer.
			 * @param hits A reference to the collider.
			 * @return void
			 */
			void clip (const std::shared_ptr< Node > & node, Physics::Collider & collider) const noexcept;

			/**
			 * @brief Checks a renderable instance for rendering.
			 * @param renderer A reference to the graphics renderer.
			 * @param renderableInstance A pointer to a renderable instance.
			 * @return void
			 */
			void checkRenderableInstance (Graphics::Renderer & renderer, Graphics::RenderableInstance::Abstract * renderableInstance) noexcept;

			/**
			 * @brief Launches the configuration of a renderable instance for all render targets.
			 * @param renderer A reference to the graphics renderer.
			 * @param renderableInstance A pointer to a renderable instance.
			 * @return void
			 */
			void updateRenderableInstanceForRendering (Graphics::Renderer & renderer, Graphics::RenderableInstance::Abstract * renderableInstance) const noexcept;

			/**
			 * @brief Updates all renderable instances from the scene with a render target.
			 * @param renderer A reference to the graphics renderer.
			 * @param renderTarget A reference to a render target smart pointer.
			 * @return void
			 */
			void updateRenderableInstancesForRendering (Graphics::Renderer & renderer, const std::shared_ptr< Graphics::RenderTarget::Abstract > & renderTarget) const noexcept;

			/* Flag names. */
			static constexpr auto ShowSectors = 0UL;
			static constexpr auto ShowBoundaries = 1UL;
			static constexpr auto ShowGroundZero = 2UL;

			MasterControl::Console m_masterControlConsole;
			std::vector< std::shared_ptr< VisualComponent > > m_sceneVisualComponents{};
			std::map< std::string , std::shared_ptr< StaticEntity > > m_staticEntities{};
			std::shared_ptr< Node > m_rootNode;
			std::map< std::string, std::shared_ptr< Scenes::OctreeSector > > m_octrees{};
			LightSet m_lightSet{};
			std::set< std::shared_ptr< AbstractModifier > > m_modifiers{};
			Physics::PhysicalEnvironmentProperties m_physicalEnvironmentProperties = Physics::PhysicalEnvironmentProperties::Earth();
			/* FIXME: Remove the three following smart pointers and use m_sceneVisualComponents instead. */
			std::shared_ptr< Graphics::Renderable::AbstractBackground > m_background{};
			std::shared_ptr< Graphics::Renderable::AbstractSceneArea > m_sceneArea{};
			std::shared_ptr< Graphics::Renderable::AbstractSeaLevel > m_seaLevel{};
			Saphir::EffectsList m_environmentEffects{};
			float m_boundary{0};
			mutable std::mutex m_sceneNodesMutex{};
			mutable std::mutex m_staticEntitiesMutex{};
			mutable std::mutex m_octreesMutex{};
			std::array< bool, 8 > m_flags{ // NOLINT(*-magic-numbers)
				false/*ShowSectors*/,
				false/*ShowBoundaries*/,
				false/*ShowGroundZero*/,
				false/*UNUSED*/,
				false/*UNUSED*/,
				false/*UNUSED*/,
				false/*UNUSED*/,
				false/*UNUSED*/
			};
	};
}
