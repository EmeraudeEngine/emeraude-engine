/*
 * Emeraude/Saphir/ShaderManager.hpp
 * This file is part of Emeraude
 *
 * Copyright (C) 2012-2023 - "LondNoir" <londnoir@gmail.com>
 *
 * Emeraude is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * Emeraude is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Emeraude; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301  USA
 *
 * Complete project and additional information can be found at :
 * https://bitbucket.org/londnoir/emeraude
 * 
 * --- THIS IS AUTOMATICALLY GENERATED, DO NOT CHANGE ---
 */

#pragma once

/* C/C++ standard libraries. */
#include <memory>
#include <map>
#include <array>

/* Local inclusions for inheritances. */
#include "ServiceInterface.hpp"

/* Local inclusions for usages. */
#include "emeraude_config.hpp"
#include "Path/File.hpp"
#include "Types.hpp"

/* Forward declarations. */
namespace Emeraude
{
	namespace Vulkan
	{
		class Device;
		class ShaderModule;
	}

	class Arguments;
	class Settings;
	class FileSystem;
}

namespace Emeraude::Saphir
{
	class ShaderCompiler;
	class AbstractShader;

	/**
	 * @brief The shader manager service class.
	 * @extends Emeraude::ServiceInterface This is a service.
	 */
	class ShaderManager final : public ServiceInterface
	{
		public:

			/** @brief Class identifier. */
			static constexpr auto ClassId{"ShaderManagerService"};

			/** @brief Observable class unique identifier. */
			static const size_t ClassUID;

			static constexpr std::array< const char * const, 6 > ShaderFileExtensions{
				VertexShaderFileExtension,
				TesselationControlShaderFileExtension,
				TesselationEvaluationShaderFileExtension,
				GeometryShaderFileExtension,
				FragmentShaderFileExtension,
				ComputeShaderFileExtension
			};

			/* Settings keys */
			static constexpr auto ShowLoadedSourceCodeKey = "Video/Shader/Manager/ShowLoadedSourceCode";
			static constexpr auto DefaultShowLoadedSourceCode = BOOLEAN_FOLLOWING_DEBUG;
			static constexpr auto SourceCodeCacheEnabledKey = "Video/Shader/Manager/SourceCodeCacheEnabled";
			static constexpr auto DefaultSourceCodeCacheEnabled = !BOOLEAN_FOLLOWING_DEBUG;
			static constexpr auto BinaryCacheEnabledKey = "Video/Shader/Manager/BinaryCacheEnabled";
			static constexpr auto DefaultBinaryCacheEnabled = !BOOLEAN_FOLLOWING_DEBUG;

			/**
			 * @brief Constructs the shader manager.
			 * @param arguments A reference to the application arguments.
			 * @param fileSystem A reference to the file system.
			 * @param coreSettings A reference to the core settings.
			 * @param shaderCompiler A reference to the shader compiler.
			 */
			ShaderManager (const Arguments & arguments, const FileSystem & fileSystem, Settings & coreSettings, ShaderCompiler & shaderCompiler) noexcept;

			/**
			 * @brief Destructs the shader manager.
			 */
			~ShaderManager () override;

			/** @copydoc Libraries::Observable::is() */
			[[nodiscard]]
			bool is (size_t classUID) const noexcept override;

			/** @copydoc Emeraude::ServiceInterface::usable() */
			[[nodiscard]]
			bool usable () const noexcept override;

			/**
			 * @brief Takes a shader generated by the Saphir system and returns a vulkan shader module.
			 * @param device A reference to a device smart pointer.
			 * @param shader A reference to a Saphir shader smart pointer.
			 * @return std::shared_ptr< Vulkan::ShaderModule >
			 */
			[[nodiscard]]
			std::shared_ptr< Vulkan::ShaderModule > getShaderModuleFromGeneratedShader (const std::shared_ptr< Vulkan::Device > & device, const std::shared_ptr< AbstractShader > & shader) noexcept;

			/**
			 * @brief Returns the instance of the shader manager.
			 * @return ShaderManager *
			 */
			[[nodiscard]]
			static
			ShaderManager * instance () noexcept;

		private:

			/** @copydoc Emeraude::ServiceInterface::onInitialize() */
			bool onInitialize () noexcept override;

			/** @copydoc Emeraude::ServiceInterface::onTerminate() */
			bool onTerminate () noexcept override;

			/**
			 * @brief Writes a shader source code on disk cache.
			 * @param shader A reference to a shader.
			 * @return bool
			 */
			bool cacheShaderSourceCode (const AbstractShader & shader) noexcept;

			/**
			 * @brief Writes a shader binary on disk cache.
			 * @param shader A reference to a shader.
			 * @return bool
			 */
			bool cacheShaderBinary (const AbstractShader & shader) noexcept;

			/**
			 * @brief Reads the cache to get shader source codes and binaries.
			 * @return void
			 */
			void readCache () noexcept;

			/**
			 * @brief Removes all sources and binary from shader cache.
			 * @return void
			 */
			void clearCache () noexcept;

			/**
			 * @brief Generates an unique cache filepath for the shader source.
			 * @param shader A reference to a shader.
			 * @return File
			 */
			[[nodiscard]]
			Libraries::Path::File generateShaderSourceCacheFilepath (const AbstractShader & shader) const noexcept;

			/**
			 * @brief Generates an unique cache filepath for the shader binary.
			 * @param shader A reference to a shader.
			 * @return File
			 */
			[[nodiscard]]
			Libraries::Path::File generateShaderBinaryCacheFilepath (const AbstractShader & shader) const noexcept;

			/**
			 * @brief Returns the shader hash from the filepath.
			 * @return size_t
			 */
			[[nodiscard]]
			static size_t extractHashFromFilepath (const Libraries::Path::File & filepath) noexcept;

			/**
			 * @brief Checks whether a binary exists in the cache.
			 * @param shader A reference to a shader.
			 * @return bool
			 */
			[[nodiscard]]
			bool checkBinaryFromCache (AbstractShader & shader) noexcept;

			/* Flag names. */
			static constexpr auto Usable = 0UL;
			static constexpr auto ShowLoadedSourceCode = 1UL;
			static constexpr auto SourceCodeCacheEnabled = 2UL;
			static constexpr auto BinaryCacheEnabled = 3UL;

			static constexpr auto ShaderSourcesDirectoryName = "shader-sources";
			static constexpr auto ShaderBinariesDirectoryName = "shader-binaries";

			static ShaderManager * s_instance; // NOLINT NOTE: Singleton behavior

			const Arguments & m_arguments;
			const FileSystem & m_fileSystem;
			Settings & m_coreSettings;
			ShaderCompiler & m_shaderCompiler;
			std::map< size_t, std::shared_ptr< Vulkan::ShaderModule > > m_shaders{};
			std::map< size_t, Libraries::Path::File > m_cachedShaderSourceCodes{};
			std::map< size_t, Libraries::Path::File > m_cachedShaderBinaries{};
			Libraries::Path::Directory m_shadersSourcesDirectory{};
			Libraries::Path::Directory m_shadersBinariesDirectory{};
			std::array< bool, 8 > m_flags{
				false/*Usable*/,
				DefaultShowLoadedSourceCode/*ShowLoadedSourceCode*/,
				DefaultSourceCodeCacheEnabled/*SourceCodeCacheEnabled*/,
				DefaultBinaryCacheEnabled/*BinaryCacheEnabled*/,
				false/*UNUSED*/,
				false/*UNUSED*/,
				false/*UNUSED*/,
				false/*UNUSED*/
			};
	};
}
