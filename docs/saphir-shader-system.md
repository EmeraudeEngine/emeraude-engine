# Saphir Shader Generation System

This document provides detailed architecture for Saphir, the automatic GLSL shader generation system that eliminates the need for hundreds of manually-written shader variants.

## Quick Reference: Key Terminology

- **Generator**: A specialized shader factory that produces GLSL code based on inputs (unknowns). Examples: SceneGenerator, OverlayGenerator, ShadowManager.
- **Unknowns**: The parameters a generator needs to produce a complete shader: Material properties, Geometry attributes, Scene context.
- **Material Requirements**: What a material needs from geometry to function (normals, tangent space, UVs, vertex colors).
- **Geometry Attributes**: What a geometry provides (positions, normals, tangents, UVs, colors) - the vertex format.
- **Compatibility Check**: Strict verification that material requirements match available geometry attributes. Failure = resource loading fails gracefully.
- **GLSL Source**: String-based shader code generated by combining hard-coded GLSL portions with variables.
- **GLSLang**: The compiler that converts generated GLSL source to SPIR-V binary for Vulkan.
- **Cache**: System that stores compiled shaders (keyed by source code hash) to avoid regeneration and recompilation.
- **Vertex Format**: Structure describing all attributes available in a geometry (queryable by generators).

## Design Philosophy: Why Saphir Exists

### The Problem: Combinatorial Explosion

Traditional approach to shaders requires manually writing every variant:

```
Manual shader files:
- shader_diffuse.glsl
- shader_diffuse_normal.glsl
- shader_diffuse_normal_specular.glsl
- shader_diffuse_normal_specular_emissive.glsl
- shader_pbr_simple.glsl
- shader_pbr_full.glsl
- shader_textured.glsl
- shader_vertexcolored.glsl
... (hundreds of permutations)
```

**Problems with manual approach:**
- **Maintenance nightmare**: Code duplication across variants
- **Error-prone**: Easy to forget variants or introduce inconsistencies
- **Inflexible**: Adding a new feature requires modifying many files
- **Costly**: Disk space, compile time, cognitive load

### Saphir's Solution: Parametric Generation

```
Saphir approach:
Material + Geometry + Scene Context
    ↓
Generator.generate()
    ↓
GLSL source (perfectly adapted)
    ↓
GLSLang.compile() → SPIR-V
    ↓
Vulkan pipeline
```

**Benefits:**
- ✅ **Zero maintenance** - Code exists once in generator
- ✅ **Always optimal** - Only includes needed features
- ✅ **No forgotten variants** - Generated on demand
- ✅ **Flexible** - New features added in one place
- ✅ **Efficient** - Cache avoids redundant work

## Architecture: Generators and Unknowns

### Core Concept: Generators Are Shaders Awaiting Their Unknowns

A generator is essentially a **parameterized shader template**. It has "holes" (unknowns) that must be filled to produce a complete shader.

```cpp
// Conceptual model
class Generator {
    // The unknowns (parameters)
    Material material;
    Geometry geometry;
    SceneContext scene;

    // The output
    string generateGLSL();
};
```

### The Three Unknowns

1. **Material (What the shader does)**
   - Which textures are used? (diffuse, normal, roughness, emissive)
   - Material model? (PBR, Phong, unlit)
   - Transparency? Blending mode?
   - Special effects? (emissive, refraction)

2. **Geometry (What data is available)**
   - Vertex format: positions, normals, tangents, UVs, colors
   - Single or multiple UV sets?
   - 2D or 3D texture coordinates?
   - Complete tangent space or normals only?

3. **Scene Context (Environment requirements)**
   - Number and types of lights (directional, point, spot)
   - Shadows enabled?
   - Post-processing requirements?
   - Render pass type (forward, deferred, shadow map)

**Output:**
- **GLSL source code** (string) - directly compilable
- **Parameters list** (optional) - for OpenGL compatibility (not needed for Vulkan)

## Material Requirements and Geometry Attributes

### How Materials Declare Requirements

Materials declare what they **need** from geometry using a basic "plan" (internal format readable by all generators):

**Four Basic Requirements:**
1. **Normals** → For lighting calculations
2. **Tangent Space** → For normal mapping (requires tangents + bitangents)
3. **Texture Coordinates** → Primary UVs (2D or 3D)
4. **Vertex Colors** → Per-vertex color attributes

**Example Material Plans:**
```cpp
// Simple diffuse material
Material simpleDiffuse {
    requires: [Normals, TextureCoordinates2D]
    textures: [diffuse]
};

// PBR with normal mapping
Material pbrFull {
    requires: [Normals, TangentSpace, TextureCoordinates2D]
    textures: [diffuse, normal, roughness, metallic]
};

// Vertex painted
Material vertexPainted {
    requires: [Normals, VertexColors]
    textures: []
};
```

### How Geometries Provide Attributes

Geometries provide their **vertex format** - what attributes they contain:

```cpp
// Geometry is queryable in two ways:

// 1. Get complete structure
VertexFormat format = geometry->getVertexFormat();
// format.hasPositions = true
// format.hasNormals = true
// format.hasTangents = false
// format.hasUVs = true (2D)
// format.hasColors = false

// 2. Query individual attributes
if (geometry->hasNormals()) { ... }
if (geometry->hasTangentSpace()) { ... }
if (geometry->hasTextureCoordinates()) { ... }
if (geometry->hasVertexColors()) { ... }
```

## Strict Compatibility Checking (Critical!)

### Core Rule: Material Requirements MUST Match Geometry Attributes

When a visual resource enters `onDependenciesLoaded()` and needs a rendering program:

```
1. Generator receives Material + Geometry
2. Generator checks: Does Geometry have ALL Material requirements?
   ✓ YES → Generate shader, compile, create pipeline
   ✗ NO  → FAIL immediately with explanatory log
3. If FAIL → onDependenciesLoaded() returns false
4. Resource never completes loading → never displayed
5. Application continues running (fail-safe)
```

**Example: Incompatible Combination**
```cpp
// Material wants normal mapping
Material material {
    requires: [Normals, TangentSpace, TextureCoordinates2D],
    textures: [diffuse, normal]
};

// Geometry doesn't have tangent space
Geometry geometry {
    attributes: [positions, normals, uvs]  // NO tangents!
};

// Result: FAILURE
Generator::check(material, geometry):
    Material requires: TangentSpace
    Geometry provides: positions, normals, uvs
    Missing: TangentSpace

    Log: "Shader generation failed for geometry 'SimpleBox' with material 'PBR_Metal':
          Required attribute missing: tangent space.
          Add tangents to geometry or use simpler material."

    return false;  // onDependenciesLoaded() returns false
    // Object never displayed, but application continues
```

**Why Strict Checking?**
- **Explicit failures** - Better to fail clearly than render incorrectly
- **Developer-friendly** - Logs explain exactly what's wrong
- **Fail-safe** - Application continues, object just not displayed
- **Forces correctness** - Cannot accidentally use incompatible combinations

## The Three Active Generators

### 1. SceneGenerator (3D Scene Objects)

**Purpose:** Generate shaders for 3D objects in the scene with full lighting, materials, and effects.

**Unknowns:**
- Material: Textures, blending, transparency, material model (PBR, Phong)
- Geometry: Vertex format (normals, tangents, UVs, colors)
- Scene Context: Number/types of lights, shadows enabled, ambient lighting

**Features:**
- Full lighting calculations (directional, point, spot lights)
- Normal mapping support (if tangent space available)
- PBR or Phong shading models
- Shadow receiving (if shadows enabled in scene)
- Texture sampling (diffuse, normal, roughness, metallic, emissive)
- Vertex colors support
- Transparency and blending modes

### 2. OverlayGenerator (2D UI/HUD)

**Purpose:** Generate shaders for on-screen 2D elements (UI, HUD, text, sprites).

**Unknowns:**
- Material: Textures, blending mode (alpha, additive, multiply)
- Geometry: Positions, UVs, vertex colors
- Scene Context: Screen dimensions, multi-layer blending requirements

**Features:**
- ❌ NO lighting - 2D screen space
- ❌ NO normal mapping - not relevant for UI
- ❌ NO shadows - 2D elements
- ✅ Screen-space positioning (2D transforms)
- ✅ Multi-layer alpha blending
- ✅ Texture sampling (UI elements, fonts, icons)
- ✅ Vertex colors for tinting
- ✅ Clipping regions

### 3. ShadowManager (Shadow Map Generation)

**Purpose:** Generate minimal shaders to render depth for shadow mapping.

**Unknowns:**
- Geometry: Positions only (nothing else needed)
- Scene Context: Light view-projection matrix, shadow map resolution

**Features:**
- ❌ NO materials - don't care about appearance
- ❌ NO textures - only depth matters
- ❌ NO lighting - generating shadows, not receiving them
- ❌ NO colors - depth only
- ✅ Minimal vertex shader (position transform only)
- ✅ Empty or minimal fragment shader (depth written automatically)

## Cache System

### Current Implementation: Post-Generation Cache

```cpp
// Current caching approach (basic)
string glslSource = generator.generate(material, geometry, scene);  // Always generate

// Hash the generated source code
string cacheKey = simpleHash(glslSource);  // e.g., SHA256 or FNV1a

if (shaderCache.contains(cacheKey)) {
    return shaderCache[cacheKey];  // Return cached SPIR-V
}

// Cache miss: compile and store
auto spirv = GLSLang.compile(glslSource);
shaderCache[cacheKey] = spirv;
return spirv;
```

**Benefits:**
- ✅ Avoids GLSLang compilation (slow - GLSL → SPIR-V)
- ✅ Avoids GPU pipeline creation (slow - SPIR-V → VkPipeline)
- ✅ Simple implementation (hash of string)

### Planned Improvement: Pre-Generation Cache

```cpp
// Planned caching approach (optimized)
// Hash inputs BEFORE generation
string cacheKey = hash(material, geometry, scene);

if (shaderCache.contains(cacheKey)) {
    return shaderCache[cacheKey];  // Return cached SPIR-V - skip generation!
}

// Cache miss: generate, compile, store
string glslSource = generator.generate(material, geometry, scene);
auto spirv = GLSLang.compile(glslSource);
shaderCache[cacheKey] = spirv;
return spirv;
```

## Integration with Resource Loading

### Saphir is a Tool, Not a System Component

Saphir is a **service/tool** used by resources during finalization:

```cpp
// Inside VisualComponent or MeshResource
bool onDependenciesLoaded() override {
    // At this point: geometry loaded + material loaded + textures loaded

    // 1. Call Saphir to generate shader
    auto shaderSource = saphir.generate(m_material, m_geometry, sceneContext);
    if (!shaderSource) {
        Log::error("Shader generation failed for '{}' with material '{}'",
                   name(), m_material->name());
        return false;  // Resource fails to load
    }

    // 2. Compile with GLSLang
    auto spirv = glslang.compile(shaderSource.value());
    if (!spirv) {
        Log::error("Shader compilation failed:\n{}", shaderSource.value());
        return false;  // Resource fails to load
    }

    // 3. Create Vulkan pipeline
    m_pipeline = vulkan.createPipeline(spirv.value(), ...);
    if (!m_pipeline) {
        return false;  // Resource fails to load
    }

    // 4. Success - resource is now ready for rendering
    return true;
}
```

**This fits perfectly with the Resource Management fail-safe architecture!**

## Common Pitfalls and Best Practices

### ❌ Common Mistakes

1. **Using PBR material on simple geometry without tangents**
   ```
   Material: "PBR_Metal" (needs tangent space)
   Geometry: "SimpleBox" (only has normals)
   → FAILURE - Add tangents or use simpler material
   ```

2. **Forgetting to export tangents from Blender/Maya**
   ```
   Exported mesh has normals but no tangents
   → Normal mapping won't work
   → Either re-export with tangents or don't use normal maps
   ```

### ✅ Best Practices

1. **Design geometries and materials together**
   - Know what attributes your materials need
   - Ensure geometries provide those attributes
   - Document requirements clearly

2. **Use default materials for testing**
   - Simple diffuse material works with minimal geometry
   - Test geometry loading before applying complex materials

3. **Check logs when objects don't display**
   - Saphir provides detailed error messages
   - Logs explain exactly what's missing
   - Fix geometry or simplify material based on logs

4. **Leverage Saphir's flexibility**
   - Don't write custom shaders unless absolutely necessary
   - Saphir handles most common cases automatically
   - Extend generators for special cases

## Design Principles Summary

| Principle | Description | Benefit |
|-----------|-------------|---------|
| **Parametric Generation** | Shaders generated from parameters (unknowns) | Eliminates manual variant explosion |
| **Strict Compatibility** | Material requirements must match geometry attributes | Prevents rendering errors, clear failures |
| **Fail-Safe Integration** | Failures logged, resource not displayed, app continues | Robustness and developer-friendly debugging |
| **Conditional Assembly** | Only include needed features in generated code | Optimal shader performance |
| **Cache Optimization** | Avoid redundant generation and compilation | Performance and efficiency |
| **Separation of Concerns** | Generators for different use cases (3D, 2D, shadows) | Clarity and maintainability |

### Core Philosophy
> "Generate the perfect shader for each combination, check compatibility strictly, fail gracefully if incompatible, cache aggressively to avoid redundant work."

## GLSL Code Generation Internals

### Declaration System: Building GLSL Structures

Saphir uses a C++ declaration system that mirrors GLSL constructs to generate syntactically correct shader code.

#### Key Classes

**1. Declaration::Structure** - GLSL struct definitions
```cpp
// Represents: struct MyStruct { mat4 field1; vec4 field2; };
Declaration::Structure structure{Struct::MyStruct};
structure.addMember(VariableType::Matrix4, "field1");
structure.addMember(VariableType::FloatVector4, "field2");
```

**2. Declaration::UniformBlock** - GLSL uniform blocks
```cpp
// Represents: layout(std140, set=0, binding=0) uniform MyBlock { ... } ubInstance;
Declaration::UniformBlock uniformBlock{
    setIndex,           // Descriptor set index
    binding,            // Binding point
    MemoryLayout::Std140,  // Memory layout (std140, std430)
    UniformBlock::Type::MyBlock,  // Block type name
    UniformBlock::Instance        // Instance name
};
uniformBlock.addMember(VariableType::Matrix4, "projectionMatrix");
```

**3. Declaration::Member::BufferBackedBlock** - Uniform block members
- Stores member name, type, array size, layout qualifiers
- For structures, stores the structure type name separately
- Generates GLSL member declarations: `mat4 myMatrix;` or `MyStruct myArray[6];`

#### Structure Type Name Storage (Critical for Arrays)

**Problem:** When using structures as array members in uniform blocks, need both:
1. The structure type name (e.g., "CubemapFace")
2. The member variable name (e.g., "faces")

**Solution:**
```cpp
// Structure stores instance name for member naming only
Declaration::Structure structure{Struct::CubemapFace, "faces"};
// "faces" used by addArrayMember() to name the array variable

// When added to uniform block
uniformBlock.addArrayMember(structure, 6);
// Internally passes structure.name() ("CubemapFace") as type name

// Member::BufferBackedBlock stores BOTH:
// - m_name = "faces" (the variable name)
// - m_structureTypeName = "CubemapFace" (the type)

// Generates correct GLSL:
// CubemapFace faces[6];  // NOT "Structure faces[6]"!
```

**Key insight:** Structure's instance name is metadata for member naming, NOT part of struct declaration output.

### Variable Access Helpers

Saphir provides helper functions to generate correct GLSL variable access patterns:

**ViewUB()** - Access uniform block members (non-cubemap)
```cpp
ViewUB("projectionMatrix")
// Generates: ubView.projectionMatrix
```

**CubeViewUB()** - Access indexed uniform block members (cubemap multiview)
```cpp
CubeViewUB("instance", "gl_ViewIndex", "projectionMatrix")
// Generates: ubView.instance[gl_ViewIndex].projectionMatrix
```

**MatrixPC()** - Access push constant matrices
```cpp
MatrixPC(PushConstant::Component::ModelMatrix)
// Generates: pcMatrices.modelMatrix
```

### Cubemap Multiview Pattern

For cubemap rendering with Vulkan multiview extension:

**Structure Definition:**
```glsl
struct CubemapFace
{
    mat4 projectionMatrix;
    vec4 positionWorldSpace;
    vec4 velocity;
    vec4 viewProperties;
    vec4 _padding;
};
```

**Uniform Block Declaration:**
```glsl
layout(std140, set = 0, binding = 0) uniform CubemapView
{
    CubemapFace faces[6];      // Per-face data (6 faces)
    vec4 ambientLightColor;    // Shared data
    float ambientLightIntensity;
} ubView;
```

**Shader Access Pattern:**
```glsl
// Access per-face data using gl_ViewIndex (0-5 for +X,-X,+Y,-Y,+Z,-Z)
mat4 projection = ubView.faces[gl_ViewIndex].projectionMatrix;
vec4 cameraPos = ubView.faces[gl_ViewIndex].positionWorldSpace;

// Access shared data directly
vec4 ambient = ubView.ambientLightColor * ubView.ambientLightIntensity;
```

**Generator Code:**
```cpp
// Create structure for per-face data
Declaration::Structure structure{Struct::CubemapFace, "faces"};
structure.addMember(VariableType::Matrix4, "projectionMatrix");
// ... add other per-face members

// Create uniform block
Declaration::UniformBlock uniformBlock{...};
uniformBlock.addArrayMember(structure, 6);  // Array of 6 faces

// Add shared data OUTSIDE the array
uniformBlock.addMember(VariableType::FloatVector4, "ambientLightColor");
uniformBlock.addMember(VariableType::Float, "ambientLightIntensity");
```

**Shader Variable Synthesis:**
When generating shader code that accesses view uniforms:
- For 2D/single view: Use `ViewUB("projectionMatrix")` → `ubView.projectionMatrix`
- For cubemap multiview: Use `CubeViewUB("faces", "gl_ViewIndex", "projectionMatrix")` → `ubView.faces[gl_ViewIndex].projectionMatrix`

### Common Pitfalls

**❌ Don't output structure instance name in declaration:**
```cpp
// WRONG - Structure outputs instance name
struct CubemapFace { ... } faces;  // "faces" here is wrong!
uniform CubemapView {
    CubemapFace faces[6];  // Conflict!
}
```

**✅ Correct - Structure defines type only:**
```cpp
// CORRECT - Structure is just a type definition
struct CubemapFace { ... };  // No instance name
uniform CubemapView {
    CubemapFace faces[6];  // Instance declared here
}
```

**❌ Don't use generic "Structure" keyword:**
```cpp
// WRONG - Using VariableType::Structure without type name
Structure faces[6];  // GLSL error: "Structure" is not a type
```

**✅ Correct - Use actual structure type name:**
```cpp
// CORRECT - Use the actual struct type name
CubemapFace faces[6];  // Valid: CubemapFace is defined above
```

### Memory Management

**Key lifetime rule:** When adding structures to uniform blocks:
- Structure's instance name (`std::string`) must be extracted immediately
- Don't store raw pointers to temporary structure's `.c_str()`
- Always copy string values or use persistent string constants

```cpp
// SAFE - Using string constant
Declaration::Structure structure{Struct::CubemapFace, "faces"};
// "faces" is a string literal → persists forever

// SAFE - Immediate extraction in addArrayMember()
const auto * name = structure.instanceName().c_str();
m_members.emplace_back(..., name, ...);  // Copied into std::string immediately
```