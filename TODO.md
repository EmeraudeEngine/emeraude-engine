# Engine TODO-list

## GENERAL
- Remove all "std::array< bool, n >".
- Remove all invalid noexcept keyword.
- Increase inlining with class methods. EDIT: Almost done.
- Improve functions args to use "std::move" when useful.
- Rewrite libs Observer/Observable pattern with the idea of static and shared objects.
- Replace all "std::stringstream" by "std::format" (c++20) for simple keys, names or identifiers generation.

## GENERAL BUGS
- Check for light coherence, create a built-in scene with a fixed directional light and multiple materials.
- Unloading objets from the scene does not release vulkan memory.
- Issue on Linux with X11, multi-monitors and NVIDIA proprietary driver. More info: https://forums.developer.nvidia.com/t/external-monitor-freezes-when-using-dedicated-gpu/265406

## CONSOLE
- Bring back a useful console behavior.

## LIBRARIES
- Add RLE to the Targa image format.
- OBJ adds the writing process.
- Remove the old MDx 3D format.
- Finish the native format.

## RESOURCES
- Merge Font from PixelFactory and FontResource.
- Check for JSON resource the direct data description.
- Check for JSON resource the store resource addition.

## SCENE :
- Create a shared dynamic uniform buffer for static entities instead of using push_constants as they normally won't move between frames. Thus, it will only hold the model matrix.
- Re-enable particle emitters. This must fundamentally be reworked from the ground.
- Check enable/disable audio on scene switching. (Shared with the AUDIO section)

## MATERIAL :
- Create a shared dynamic uniform buffer when a material does not use sampler. Pay attention to the real benefit of that solution.
- Create a material editor in JavaScript (application side).

## TEXTURING :
- Read settings when generating samplers.
- Finish 1D and 3D textures.

## RENDERING :
- Enable additional render targets next to the main one to create shadow maps, 2D textures and reflections.
- Study and create the cubemap rendering (single-pass) to be able to produce reflections and shadow cubemap.
- Improve the rendering branches to reduce cost.
- Check sprite blending.
- Check sprite texture clamping to edges.
- Re-enable the screenshot from the engine.

## SHADERS GENERATION :
- Check source and binary caches.
- Prepare a way to use manual GLSL sources.
- Re-enable normal calculation bypass when the surface is not facing a light.

## LIGHTING :
- Fix the ambient light update against the render target which uses it.
- Re-enable the ambient light color generated by the averaging active light color.
- Check the ambient light color generated by a texture.
- Check what the light matrix for a shadow map is and how to update it. Hint, this is an MVP matrix from the light point of view.
- Check light radius against entities to discard some useless rendering.
- Shadow maps: Create a re-usable shadow map for ephemere lights.

## PHYSICS :
- Enable the rotational physics.

## ANIMATION :
- (Prior) Check all animatable properties for all objects.
- Remove Variant for "std::any".

## OVERLAY :
- Rework ComposedSurface from overlay to create a native menu.
- Rewrite the TextWriter class.

## AUDIO :
- Check to stop sound from an inactive scene. (Shared with SCENE section)

## GENERAL VULKAN :
- Implement descriptorIndexing from Vulkan 1.2
- Implement VK_KHR_synchronization2 and VK_KHR_dynamic_rendering from Vulkan 1.3
- Check validation layers and debug messenger relationship. (According to khronos, this is valid to create the debug messenger without validation layers)
- Fix texture loading. (UINT â†’ UNORM) Convert data before? or not?
- Use of a separated image from a sampler in GLSL when useful.
- Find a better solution to handle shared uniform buffer objects.
- Find a better way to create and store a descriptor set layout.
- Find a way to order the rendering by pipeline layout to reduce the binding cost per draw.
- Check for the right way to push constant from the right shader declaration to the right stage in vulkan. (GraphicsShaderGenerator.cpp:254)
- Check waitIdle() for a device in every corner of the engine. Sometimes the device is lost.
- Analyze UBO and instanced VBO usage and make a better and global shared UBO/VBO optimization for short life entity.
